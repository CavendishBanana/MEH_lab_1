// MEH - Laboratorium 1 - Krzysztof Gryko
//

#include <iostream>
#include "LinearCongruentialGenerator.h"
#include <string>;
#include <map>
#include <math.h>
#include <fstream>

#include <algorithm> 
#include <cctype>
#include <locale>
constexpr double pi = 3.14159265358979323846;

using namespace std;
// trim from start (in place)
inline void ltrim(std::string& s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !std::isspace(ch);
        }));
}

// trim from end (in place)
inline void rtrim(std::string& s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !std::isspace(ch);
        }).base(), s.end());
}

inline void trim(std::string& s)
{
    ltrim(s);
    rtrim(s);
}

LinearCongruentialGenerator use_custom_LCG_settings() 
{
    cout << "Input the number of seeds: ";
    unsigned long long number_of_seeds = 0;
    unsigned long long* seeds, * a_params;
    cin >> number_of_seeds;
    seeds = new unsigned long long[number_of_seeds];
    a_params = new unsigned long long[number_of_seeds];
    cout << "\n";
    for (unsigned long long i = 0; i < number_of_seeds; i++)
    {
        cout << "input seed " << i + 1 << ": ";
        unsigned long long seed, a_param;
        cin >> seed;
        cout << "\ninput seed " << i + 1 << " multiplier: ";
        cin >> a_param;
        seeds[i] = seed;
        a_params[i] = a_param;
    }
    unsigned long long m, c;
    cout << "\ninput c: ";
    cin >> c;
    cout << "\ninput m: ";
    cin >> m;
    LinearCongruentialGenerator lcg = LinearCongruentialGenerator(a_params, seeds, number_of_seeds, c, m);
    delete[] seeds;
    delete[] a_params;
    return lcg;
}

LinearCongruentialGenerator use_default_LCG_settings()
{
     LinearCongruentialGenerator lcg = LinearCongruentialGenerator();
     lcg.set_seed(0, 43);
     return lcg;
}


double map_to_minus_one_to_one(unsigned long long value, double max_value_inverted)
{
    return value * max_value_inverted * 2.0 - 1.0;
}

double find_pi_with_monte_carlo(LinearCongruentialGenerator& lcg, int iterations_count, unsigned long long int max_value_from_lcg=0)
{
    if (max_value_from_lcg == 0)
    {
        max_value_from_lcg = lcg.get_m_param() - 1;
    }
    double max_val_inv = 1.0 / max_value_from_lcg;
    double previous = map_to_minus_one_to_one(lcg.next(), max_val_inv);
    double next = 0.0;
    int points_inside_circle = 0;
    for (int i = 0; i < iterations_count; i++)
    {
        next = map_to_minus_one_to_one(lcg.next(), max_val_inv);
        if ((previous * previous + next * next) <= 1.0)
        {
            points_inside_circle++;
        }
        previous = next;
    }
    return (4.0 * static_cast<double>(points_inside_circle)) / iterations_count;
}


int main()
{
    cout << "Use default settings or input parameters of generator? y/n\n";
    string answer;
    cin >> answer;
    LinearCongruentialGenerator lcg = use_default_LCG_settings();
    if (answer != "Y" && answer != "y")
    {
        lcg = use_custom_LCG_settings();
    }
    cout << "\nInput the number of random numbers samples to generate (or n for default 100 000): ";
    unsigned long long samples_count = 0;
    string samples_count_str = "";
    cin >> samples_count_str;
    trim(samples_count_str);
    if(samples_count_str == "n")
    {
        samples_count = 100000;
    }
    else
    {
        samples_count = stoi(samples_count_str);
    }

    LinearCongruentialGenerator copy_of_created_generator = lcg;
    unsigned long long greatest_value = lcg.get_m_param();
    //find max value by searching for greatest value in 100 x number of samples used to find parameters
    /*LinearCongruentialGenerator generator_to_find_greatest_value = lcg;
    
    for (int i = 0; i < 100 * samples_count; i++)
    {
        unsigned long long next_num = generator_to_find_greatest_value.next();
        if (next_num > greatest_value)
        {
            greatest_value = next_num;
        }
    }
    cout << "Greatest value found after generating 100 * samples_count: " << greatest_value << endl;*/
    
    // greatest_value inverse will serve as probabilty of generating given number - assumed that numbers generated by LCG have homogenous distribution
    //prepare variables and objects to store data to find expected mean, standard deviation and histogram
    unsigned long long sum_of_numbers_from_lcg{ 0l };
    double expected_value{ 0.0 }, standard_deviation{0.0}, standard_deviation_x_i_sqared_times_prob_i{0.0};
    map<unsigned long long, unsigned long long> histogram = map<unsigned long long,unsigned long long>();
    double inv_possible_values_count = 1.0 / static_cast<double>(greatest_value);
    
    cout << "Begin generating numbers" << endl;
    for (unsigned long long i = 0; i < samples_count; i++)
    {
        unsigned long long generated_number = lcg.next();
        expected_value += static_cast<double>(generated_number) * inv_possible_values_count;
        if (histogram.count(generated_number) == 0)
        {
            //histogram.insert({ generated_number, 0 });
            histogram[generated_number] = 0;
        }
        histogram[generated_number] = histogram[generated_number] + 1;
        standard_deviation_x_i_sqared_times_prob_i += generated_number * generated_number * inv_possible_values_count;
    }
    standard_deviation = sqrt(standard_deviation_x_i_sqared_times_prob_i - expected_value * expected_value);
    cout << "expected value: " << expected_value << " standard deviation: " << standard_deviation << endl;
    
    //save histogram data
    
    ofstream filestream = ofstream("histogram.csv");
    for (auto it = histogram.begin(); it != histogram.end(); ++it)
    {
        filestream << to_string(it->first) + "; " + to_string(it->second) + "\n";
    }
    filestream.close();


    //Zadanie 2

    LinearCongruentialGenerator lcg2 = copy_of_created_generator;
    int number_of_iterations[] = {10,100,1000,10000};
    int iterations_variants_count = 4;
    for (int i = 0; i < iterations_variants_count; i++)
    {
        LinearCongruentialGenerator lcg = LinearCongruentialGenerator(43);
        double monte_carlo_pi = find_pi_with_monte_carlo(lcg, number_of_iterations[i], greatest_value);
        cout << "Pi computed with monte carlo method for " << number_of_iterations[i] << " iterations: " << monte_carlo_pi << ", computed pi and constant pi ratio: " << monte_carlo_pi / pi<< endl;
        
    }
    return 0;
}



